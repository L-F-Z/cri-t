// Copyright 2025 Fengzhi Li
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package apt

import (
	"crypto/sha1"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/binary"
	"encoding/pem"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// The SubjectNameHash() function and the sub-functions related to it
// are all directly copied from:
// https://github.com/paketo-buildpacks/ca-certificates/blob/v1.0.1/cacerts/certs.go

type canonicalATV struct {
	Type  asn1.ObjectIdentifier
	Value string `asn1:"utf8"`
}
type canonicalSET []canonicalATV

func canonicalString(s string) string {
	s = strings.TrimLeft(s, " \f\t\n\v")
	s = strings.TrimRight(s, " \f\t\n\v")
	s = strings.ToLower(s)
	return string(regexp.MustCompile(`[[:space:]]+`).ReplaceAll([]byte(s), []byte(" ")))
}

func canonicalName(name []byte) ([]byte, error) {
	var origSeq pkix.RDNSequence
	_, err := asn1.Unmarshal(name, &origSeq)
	if err != nil {
		return nil, fmt.Errorf("failed to parse subject name\n%w", err)
	}
	var result []byte
	for _, origSet := range origSeq {
		var canonSet canonicalSET
		for _, origATV := range origSet {
			origVal, ok := origATV.Value.(string)
			if !ok {
				return nil, errors.New("got unexpected non-string value")
			}
			canonSet = append(canonSet, canonicalATV{
				Type:  origATV.Type,
				Value: canonicalString(origVal),
			})
		}
		setBytes, err := asn1.Marshal(canonSet)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal canonical name\n%w", err)
		}
		result = append(result, setBytes...)
	}
	return result, nil
}

func subjectNameHash(cert *x509.Certificate) (uint32, error) {
	name, err := canonicalName(cert.RawSubject)
	if err != nil {
		return 0, fmt.Errorf("failed to compute canonical subject name\n%w", err)
	}
	hasher := sha1.New()
	_, err = hasher.Write(name)
	if err != nil {
		return 0, fmt.Errorf("failed to compute sha1sum of canonical subject name\n%w", err)
	}
	sum := hasher.Sum(nil)
	return binary.LittleEndian.Uint32(sum[:4]), nil
}

func certHashName(certPath string) (hashName string, err error) {
	data, err := os.ReadFile(certPath)
	if err != nil {
		err = fmt.Errorf("failed to read certificate file: %v", err)
		return
	}
	block, _ := pem.Decode(data)
	if block == nil {
		err = fmt.Errorf("failed to decode PEM block")
		return
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		err = fmt.Errorf("failed to parse certificate: %v", err)
		return
	}
	name, err := subjectNameHash(cert)
	if err != nil {
		err = fmt.Errorf("failed to calculate name: %v", err)
		return
	}
	hashName = fmt.Sprintf("%08x.0", name)
	return
}

func createCert(root string, certFilenames []string) (err error) {
	confRelPath := "/etc/ca-certificates.conf"
	confPath := filepath.Join(root, confRelPath)
	confFile, err := os.Create(confPath)
	if err != nil {
		err = fmt.Errorf("error occured when creating ca-certificates.conf file: [%v]", err)
		return
	}
	defer confFile.Close()

	heading := `# This file lists certificates that you wish to use or to ignore to be
# installed in /etc/ssl/certs.
# update-ca-certificates(8) will update /etc/ssl/certs by reading this file.
#
# This is autogenerated by dpkg-reconfigure ca-certificates.
# Certificates should be installed under /usr/share/ca-certificates
# and files with extension '.crt' is recognized as available certs.
#
# line begins with # is comment.
# line begins with ! is certificate filename to be deselected.
#`
	_, err = confFile.WriteString(heading)
	if err != nil {
		return fmt.Errorf("error occured when writing ca-certificates.conf file: [%v]", err)
	}
	for _, filename := range certFilenames {
		_, err := confFile.WriteString("\n" + filepath.Join("mozilla", filename))
		if err != nil {
			return fmt.Errorf("error occured when writing ca-certificates.conf file: [%v]", err)
		}
	}
	return
}

func createSymlinks(root string, certFilenames []string) (err error) {
	for _, filename := range certFilenames {
		certPath := filepath.Join("/usr/share/ca-certificates/mozilla", filename)
		purename := strings.TrimSuffix(filename, filepath.Ext(filename))
		pemPath := filepath.Join(root, "/etc/ssl/certs", purename+".pem")
		err := os.Symlink(certPath, pemPath)
		if err != nil {
			return fmt.Errorf("error occured when creating symlink %s -> %s: [%v]", pemPath, certPath, err)
		}

		realCertPath := filepath.Join(root, certPath)
		hashName, err := certHashName(realCertPath)
		hashPath := filepath.Join(root, "/etc/ssl/certs", hashName)
		if err != nil {
			return fmt.Errorf("error occured when calculating cert file %s name hash: [%v]", filename, err)
		}
		err = os.Symlink(purename+".pem", hashPath)
		if err != nil {
			return fmt.Errorf("error occured when creating symlink %s -> %s: [%v]", hashName, purename+".pem", err)
		}
	}
	return
}

func combineCerts(root string, certFilenames []string) (err error) {
	combinePath := filepath.Join(root, "/etc/ssl/certs/ca-certificates.crt")
	combineFile, err := os.Create(combinePath)
	if err != nil {
		return fmt.Errorf("error occured when creating ca-certificates.crt file: [%v]", err)
	}
	defer combineFile.Close()

	for _, filename := range certFilenames {
		path := filepath.Join(root, "/usr/share/ca-certificates/mozilla", filename)
		certFile, err := os.Open(path)
		if err != nil {
			return fmt.Errorf("error opening certificate file %s: [%v]", path, err)
		}
		defer certFile.Close()
		_, err = io.Copy(combineFile, certFile)
		if err != nil {
			return fmt.Errorf("error copying certificate file %s to combine: [%v]", path, err)
		}
	}
	return
}

func updateCaCertificates(root string) (err error) {
	certPath := "/usr/share/ca-certificates/mozilla"
	certFullPath := filepath.Join(root, certPath)

	files, err := os.ReadDir(certFullPath)
	if err != nil {
		log.Fatalf("error occured when reading certificates directory: [%v]", err)
	}
	var certFilenames []string
	for _, file := range files {
		certFilenames = append(certFilenames, file.Name())
	}
	sort.Strings(certFilenames)

	err = createCert(root, certFilenames)
	if err != nil {
		return
	}
	err = createSymlinks(root, certFilenames)
	if err != nil {
		return
	}
	err = combineCerts(root, certFilenames)
	if err != nil {
		return
	}
	return
}
