package storage

import (
	"time"

	"github.com/L-F-Z/TaskC/pkg/bundle"
)

const (
	// volatileFlag     = "Volatile"
	mountLabelFlag   = "MountLabel"
	processLabelFlag = "ProcessLabel"
	// mountOptsFlag    = "MountOpts"
)

// A Container is a reference to a read-write layer with metadata.
type Container struct {
	// ID is either one which was specified at create-time, or a random
	// value which was generated by the library.
	ID string `json:"id"`

	// Names is an optional set of user-defined convenience values.  The
	// container can be referred to by its ID or any of its names.  Names
	// are unique among containers.
	Names []string `json:"names,omitempty"`

	// ImageID is the ID of the image which was used to create the container.
	ImageID string `json:"image"`

	// LayerID is the ID of the read-write layer for the container itself.
	// It is assumed that the image's top layer is the parent of the container's
	// read-write layer.
	LayerID string `json:"layer"`

	// Metadata is data we keep for the convenience of the caller.  It is not
	// expected to be large, since it is kept in memory.
	Metadata string `json:"metadata,omitempty"`

	// Created is the datestamp for when this container was created.  Older
	// versions of the library did not track this information, so callers
	// will likely want to use the IsZero() method to verify that a value
	// is set before using it.
	Created time.Time `json:"created,omitempty"`

	Flags map[string]interface{} `json:"flags,omitempty"`

	// volatileStore is true if the container is from the volatile json file
	volatileStore bool `json:"-"`
}

func (c *Container) ProcessLabel() string {
	if label, ok := c.Flags[processLabelFlag].(string); ok {
		return label
	}
	return ""
}

func (c *Container) MountLabel() string {
	if label, ok := c.Flags[mountLabelFlag].(string); ok {
		return label
	}
	return ""
}

type InstanceServer struct {
	root string
}

func (s *InstanceServer) Root() string {
	return s.root
}

// CreateContainer creates a new container, optionally with the
// specified ID (one will be assigned if none is specified), with
// optional names, using the specified image's top layer as the basis
// for the container's layer, and assigning the specified ID to that
// layer (one will be created if none is specified).  A container is a
// layer which is associated with additional bookkeeping information
// which the library stores for the convenience of its caller.
func (s *InstanceServer) CreateContainer(id string, names []string, bundleId bundle.BundleId, metadata string, labelOptions []string) (*Container, error) {
	return nil, nil
}

// Container returns a specific container.
func (s *InstanceServer) Container(id string) (*Container, error) {
	return nil, nil
}

// Containers returns a list of the currently known containers.
func (s *InstanceServer) Containers() ([]Container, error) {
	return []Container{}, nil
}

// DeleteContainer removes the specified container and its layer.  If
// there is no matching container, or if the container exists but its
// layer does not, an error will be returned.
func (s *InstanceServer) DeleteContainer(id string) error {
	return nil
}

// ContainerDirectory returns a path of a directory which the caller
// can use to store data, specific to the container, which the library
// does not directly manage.  The directory will be deleted when the
// container is deleted.
func (s *InstanceServer) ContainerDirectory(id string) (string, error) {
	return "", nil
}

// ContainerRunDirectory returns a path of a directory which the
// caller can use to store data, specific to the container, which the
// library does not directly manage.  The directory will be deleted
// when the host system is restarted.
func (s *InstanceServer) ContainerRunDirectory(id string) (string, error) {
	return "", nil
}

// Metadata retrieves the metadata which is associated with a layer,
// image, or container (whichever the passed-in ID refers to).
func (s *InstanceServer) Metadata(id string) (string, error) {
	return "", nil
}

// SetMetadata updates the metadata which is associated with a layer,
// image, or container (whichever the passed-in ID refers to) to match
// the specified value.  The metadata value can be retrieved at any
// time using Metadata, or using Layer, Image, or Container and reading
// the object directly.
func (s *InstanceServer) SetMetadata(id, metadata string) error {
	return nil
}

func (s *InstanceServer) GetUsage(id string) (bytesUsed uint64, inodeUsed uint64) {
	return 0, 0
}

// Mount attempts to mount a layer, image, or container for access, and
// returns the pathname if it succeeds.
// Note if the mountLabel == "", the default label for the container
// will be used.
//
// Note that we do some of this work in a child process.  The calling
// process's main() function needs to import our pkg/reexec package and
// should begin with something like this in order to allow us to
// properly start that child process:
//
//	if reexec.Init() {
//	    return
//	}
func (s *InstanceServer) Mount(id, mountLabel string) (string, error) {
	return "", nil
}

// Unmount attempts to unmount a layer, image, or container, given an ID, a
// name, or a mount path. Returns whether or not the layer is still mounted.
// WARNING: The return value may already be obsolete by the time it is available
// to the caller, so it can be used for heuristic sanity checks at best. It should almost always be ignored.
func (s *InstanceServer) Unmount(id string, force bool) (bool, error) {
	return true, nil
}

// FromContainerDirectory is a convenience function which reads
// the contents of the specified file relative to the container's
// directory.
func (s *InstanceServer) FromContainerDirectory(id, file string) ([]byte, error) {
	return []byte{}, nil
}

// Tries to clean up remainders of previous containers or layers that are not
// references in the json files. These can happen in the case of unclean
// shutdowns or regular restarts in transient store mode.
func (s *InstanceServer) GarbageCollect() error {
	return nil
}
